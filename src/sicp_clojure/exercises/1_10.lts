// Attempt at modelling the following in FSP.
//(define (A x y)
//  (cond ((= y 0) 0)
//        ((= x 0) (* 2 y))
//        ((= y 1) 2)
//        (else (A (- x 1)
//                 (A x (- y 1))))))

const N = 5

const X = 1
const Y = 3

// NOTE: For A_ITER i am using a max value of Y of N-1, actually this will be reduced for each level of recursion and this isn't being
// represented at the moment
A = A[X][Y],
A[x:0..N][y:0..0] 			= (result_a[0]   -> STOP),
A[x:0..0][y:1..N] 			= (result_b[2*y] -> STOP),
A[x:1..N][y:1..1] 			= (result_c[2]   -> STOP),
A[x:1..N][y:2..N] 			= (recur 		 -> A_ITER[x][y-1]),
A_ITER[x:0..N][y:0..0] 		= (found_y   	 -> A[x-1][0]),
A_ITER[x:0..0][y:1..N-1] 	= (found_y 		 -> A[x-1][2*y]),
A_ITER[x:1..N][y:1..1] 		= (found_y   	 -> A[x-1][2]),
A_ITER[x:1..N][y:2..N-1] 	= (recur         -> A_ITER[x][y-1]).

// Above can successfully calcuate (A 1 2) = 4 but not (A 1 3) = 8


// Another possible approach but run into same issue with the recursive case. 
// Not working for any inputs at present.
A1 = (a[x:0..N][y:0..0] -> result[0] -> A |
	  a[x:0..0][y:1..N] -> result[2*y] -> A |
	  a[x:1..N][y:1..1] -> result[2] -> A |
	  a[x:1..N][y:2..N] -> something -> A).

X1Y2 = (a[1][1] -> X1Y2).

|| ANS = (A1 || X1Y2).

		



